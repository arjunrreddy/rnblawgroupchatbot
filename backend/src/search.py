import yaml
import openai
import json
import os
from openai import OpenAI
from difflib import SequenceMatcher
import difflib

# Constants
TRANSCRIPT_FILE = "data/structured_transcripts/march_11.json"
VIDEO_URL = "https://www.facebook.com/rnlawgroupUS/videos/498204740023527/"

# Load API Key
def load_config():
    api_key = os.getenv("OPENAI_API_KEY")
    if api_key:
        return {"openai_api_key": api_key}

    # Fallback to local config.yaml (for local dev)
    config_path = os.path.join(os.path.dirname(__file__), "../config/config.yaml")
    try:
        with open(config_path, "r") as file:
            return yaml.safe_load(file)
    except FileNotFoundError:
        raise RuntimeError("‚ùå ERROR: OPENAI_API_KEY not found in environment or config.yaml.")

config = load_config()
api_key = config.get("openai_api_key", None)

client = OpenAI(api_key=api_key)

def load_structured_transcript():
    """Load the structured transcript with timestamps."""
    if not os.path.exists(TRANSCRIPT_FILE):
        return []

    with open(TRANSCRIPT_FILE, "r") as f:
        return json.load(f)

def get_full_transcript():
    """Load both the full transcript text and the structured transcript."""
    if not os.path.exists(TRANSCRIPT_FILE):
        return "", []  # Return an empty transcript and an empty list if file doesn't exist

    with open(TRANSCRIPT_FILE, "r") as f:
        transcript_data = json.load(f)

    full_text = "\n".join([segment["text"] for segment in transcript_data])
    
    return full_text, transcript_data

def find_best_video_segment(query, chatbot_response, full_transcript_text, structured_transcript, video_duration):
    """
    Find the best timestamp in the video by analyzing:
    - The user's query.
    - The chatbot's response (AI-generated summary).
    - The full podcast transcript.
    - The structured transcript with timestamps.
    """

    # üîπ Step 1: AI Determines the **Exact** Position in the Transcript
    timestamp_prompt = f"""
    You are analyzing a legal podcast transcript to find the most relevant timestamp for a user's question.

    ---
    **User's Question:**  
    "{query}"

    **AI-Generated Chatbot Response:**  
    This response was generated by an AI chatbot and is **not a direct quote** from the podcast:  
    "{chatbot_response}"

    ---
    **Your Task:**  
    1. Identify the **section of the transcript** that **best answers the user's question**.  
    2. Prioritize sections that the chatbot response was **likely based on**.  
    3. Extract the **start timestamp (in seconds)** of that section **from the structured transcript**.  
    4. Ensure the timestamp is **less than the total video duration** ({video_duration} seconds).  
    5. If no exact match is found, return the **closest matching timestamp** from the transcript.  
    6. **Respond with only the number** (e.g., "123"), with no extra text or symbols.

    **Structured Podcast Transcript:**  
    {structured_transcript}
    """

    try:
        match_response = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "system", "content": "You are an AI assistant finding relevant transcript text and timestamps."},
                {"role": "user", "content": timestamp_prompt}
            ]
        )

        # Extract raw AI response
        raw_timestamp = match_response.choices[0].message.content.strip()
        print(f"üîç AI Suggested Timestamp: {raw_timestamp}")

        # üîπ Step 2: Convert AI Response to a Valid Timestamp
        try:
            best_timestamp = int(float(raw_timestamp))  # Convert to integer timestamp
            print(f"üéØ Final Timestamp Found: {best_timestamp}s")
        except ValueError:
            print(f"‚ö†Ô∏è AI returned invalid timestamp: {raw_timestamp}")
            return None

        # üîπ Step 3: Ensure Timestamp is Valid and Within Range
        best_timestamp = max(0, min(best_timestamp - 2, video_duration))  # Adjust for context
        return best_timestamp

    except Exception as e:
        print(f"‚ùå ERROR finding best timestamp: {e}")
        return None